<head>
  <link
    rel="stylesheet"
    href="https://mostlymaths.net/webfonts/reforma/reforma.css"
  />
  <link rel="stylesheet" href="https://mostlymaths.net/webfonts/monoid.css" />
  <style>
    body {
      background: #002b36 !important;
      font-size: 40px;
    }
    li {
      padding-left: 1em;
      list-style-type: "- ";
    }
    #body {
      border-radius: 2px;
      line-height: 1.5;
      font-weight: 100;
      padding: 5%;
      caret-color: green;
      width: 100%;
      height: 100%;
      background: #fdf6e3;
      color: #657b83;
    }
    #body:focus {
      outline: none;
    }
    .dark {
      background: #002b36 !important;
      color: #839496 !important;
      caret-color: #93a1a1 !important;
    }
    hr {
      border: 1px solid #657b83 !important;
    }
    .mono {
      font-family: "monoidregular";
      font-size: 95%;
    }
    .serif {
      font-family: "Reforma1969";
      font-size: 100%;
    }
    #info {
      position: absolute;
      right: 2em;
      top: 2em;
      opacity: 1;
      transition: opacity 1s ease-in-out;
    }
    .alive {
      border-radius: 6px;
      background: #eee;
      padding-left: 0.3em;
      padding-right: 0.3em;
      font-family: "monoidregular";
      font-size: 80%;
    }
    .fades {
      opacity: 0 !important;
    }
    div.wrap {
      display: inline-block;
    }
  </style>
</head>
<body>
  <div id="body" class="dark" contenteditable></div>
  <div id="info"></div>
</body>
<script>
  const currentHash = window.location.hash.substring(1);
  const decodedHash = decodeURIComponent(currentHash);
  const body = document.querySelector("#body");
  const info = document.querySelector("#info");
  const zwsr = () => document.createTextNode("\u200b")
  body.innerHTML = decodedHash;
  function save() {
    const regex =
      /<div class="wrap"><[^\s]+ class="alive">([^<]+)<\/[^>]+><\/div>/g;
    const streamlined = body.innerHTML.replaceAll(regex, "$1");
    console.log(streamlined);
    const encodedBodyContent = encodeURIComponent(streamlined);

    window.location.hash = encodedBodyContent;
    info.innerHTML = "&#x1F4BE;";
    info.classList.add("fades");
  }
  function reset() {
    info.classList.remove("fades");
    info.innerText = "";
  }
  function common(ev) {
    reset();
    return ev.button !== 0;
  }
  /*body.addEventListener("mousedown", (event) => {
    info.classList.remove("fades");
    info.innerText = "";
  });*/
  body.addEventListener("dblclick", (event) => {
    const selectedText = window.getSelection();
    const range = selectedText.getRangeAt(0);
    if (
      event.srcElement.classList.length > 0 &&
      event.srcElement.classList.contains("alive")
    ) {
      return;
    }
    let node;
    if (selectedText == "b" || selectedText == "bold") {
      node = document.createElement("b");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        document.execCommand("bold", false, null);
      };
    }
    if (selectedText == "u" || selectedText == "underline") {
      node = document.createElement("u");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        document.execCommand("underline", false, null);
      };
    }
    if (selectedText == "i" || selectedText == "italic") {
      node = document.createElement("i");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        document.execCommand("italic", false, null);
      };
    }
    if (selectedText == "ðŸ’¾" || selectedText == "save") {
      node = document.createElement("u");
      console.log("save");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        save();
        ev.stopPropagation();
      };
    }
    if (selectedText == "fontdown") {
      node = document.createElement("u");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        const fontSize = getComputedStyle(document.body).fontSize;
        const newFontSize = parseFloat(fontSize) - 2;
        document.body.style.fontSize = `${newFontSize}px`;
      };
    }
    if (selectedText == "dark") {
      node = document.createElement("u");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        body.classList.toggle("dark");
      };
    }
    if (selectedText == "mono") {
      node = document.createElement("u");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        body.classList.remove("serif");
        body.classList.remove("mono");
        body.classList.add("mono");
      };
    }
    if (selectedText == "serif") {
      node = document.createElement("u");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        body.classList.remove("mono");
        body.classList.remove("serif");
        body.classList.add("serif");
      };
    }
    if (selectedText == "fontup") {
      node = document.createElement("u");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        const fontSize = getComputedStyle(document.body).fontSize;
        const newFontSize = parseFloat(fontSize) + 2;
        document.body.style.fontSize = `${newFontSize}px`;
      };
    }
    if (selectedText == "new") {
      node = document.createElement("u");
      node.onmousedown = (ev) => {
        if (common(ev)) {
          return;
        }
        body.innerHTML = "";
      };
    }
    if (node) {
      let div = document.createElement("div");
      node.innerHTML = selectedText;
      div.classList.toggle("wrap");
      node.classList.toggle("alive");
      range.deleteContents();
      div.appendChild(node);
      range.insertNode(div);
      div.insertAdjacentHTML("beforebegin", "&thinsp;");
      div.insertAdjacentHTML("afterend", "&thinsp;");
    }
  });
  keyStack = ["Enter"]; // TODO Fishy on load though
  listing = false; // TODO Horrible state machine
  body.addEventListener("keyup", (event) => {
    const ek = event.key // TODO ref
    console.log(event);
    if (event.ctrlKey && event.key === "s") {
      save();
    } else {
      if (event.key !== "Control") {
        reset();
      }
    }
    if (!["-", "Enter", " "].includes(ek)){
      keyStack = []
    }
    if (event.key === "-") {
      if (keyStack[0] == "Enter") {
        keyStack.push("-");
        console.log(keyStack)
        console.log(keyStack.slice(1).join(""))
        if(keyStack.slice(1).join("") === "---"){
          const zws = zwsr()
          keyStack = ["Enter"] // We want possibly lists in this case
          const selection = window.getSelection();
          selection.extend(selection.anchorNode, 0);
          range = selection.getRangeAt(0);
          range.deleteContents();
          hr = document.createElement("hr");
          range.insertNode(zws)
          range.insertNode(hr);
          //range.collapse(false);
          let newRange= document.createRange()
          newRange.setStartAfter(zws);
          //newRange.setEndBefore(li);
          selection.removeAllRanges();
          selection.addRange(newRange);
          
        }
      }
    }
    if (event.key === "Enter") {
      const selection = window.getSelection();
      if(listing && keyStack.length == 0){
        nbsp = document.createTextNode("\u00A0")
        
        const range = selection.getRangeAt(0)
        listing.push(selection.anchorNode) // That should be the li
        //range.insertNode(nbsp)
      }
      if(keyStack.length && keyStack[0] == "Enter" && listing){
        const zws = zwsr()
        console.log("deleting")
        console.log(selection)
        let range = document.createRange()
        range.setStartBefore(listing[listing.length-1])//selection.anchorNode)
        range.setEndAfter(selection.anchorNode)
        range.deleteContents()
         // Zero width space, TODO: remove on save
        range.insertNode(zws)
        selection.removeAllRanges();
        range.setStartAfter(zws)//listing[0]);
        selection.addRange(range);
        listing = false // Hah!
      }
      if(!listing && selection.anchorNode.nodeName == "LI"){
        listing = [selection.anchorNode]
      }
      keyStack = [];
      keyStack.push("Enter");
    }
    if (event.key === " ") {
      if (keyStack[0] == "Enter" && keyStack[1] == "-") {
        const selection = window.getSelection();
        //if (selection.anchorOffset == 2) {
          const zws = zwsr()
          selection.extend(selection.anchorNode, 0);
          range = selection.getRangeAt(0);
          range.deleteContents();
          li = document.createElement("li");
          li.appendChild(zws)
          range.insertNode(li);
          range.collapse(false);
          let newRange= document.createRange()
          newRange.setStartAfter(li);
          //newRange.setEndBefore(li);
          selection.removeAllRanges();
          selection.addRange(newRange);
          listing = [li]
          keyStack = [];
       //}
      //} else {
      //  console.log("nope");
      }
    }
  });
</script>
